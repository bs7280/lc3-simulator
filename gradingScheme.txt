CS 350 - FINAL PROJECT GRADING GUIDE  version 2014-12-04
------------------------------------

Please fill in the information below; I'll verify it and use it to guide the grading

Instructions:
------------
Do not turn in a program that doesn't compile because of errors.
(You get points off if it compiles with warnings, but you can turn it in.)

For each category below, leave it blank if you haven't written code for
it, otherwise mark it:
	y - Your program does this (or has this, if it's a syntactic feature)
	b - If you've written code for this but it's buggy
	c - if you've written code for this but haven't tested it

(Lines marked XC are extra credit; your program has to basically
work before you can get extra credit.)

Y	Compiling - Program compiles without warnings

Y	CPU declaration - correct Word and Address
Y	CPU declaration - cc (condition code) has some reasonable structure
Y	CPU declaration - has necessary fields
Y	CPU declaration - no unnecessary fields

Y	Main program - passes argc/argv to initialize memory
Y	Main program - calls routines to initialize cpu
Y	Main program - calls routines to dump control unit, memory

Y	Initialize control unit - sets pc
Y	Initialize control unit - sets ir
Y	Initialize control unit - sets cc
Y	Initialize control unit - sets running flag
Y	Initialize control unit - sets registers

Y	Initialize memory - figures out which file to open
Y	Initialize memory - checks for nonexistent file to read from
Y	Initialize memory - reads using correct %format
Y	Initialize memory - reads/handles .origin
Y	Initialize memory - reads/stores memory values
Y	Initialize memory - has no buffer memory leak
Y	Initialize memory - handles EOF
Y	Initialize memory - zeros rest of memory
C	XC	Initialize memory - Handles badly-formed input
C	XC	Initialize memory - Complains about bad memory addresses

Y	Dump control unit - prints pc
Y	Dump control unit - prints ir
Y	Dump control unit - prints cc
Y	Dump control unit - prints running flag
Y	Dump control unit - prints registers
Y	Dump control unit - prints using reasonable %format
Y	Dump control unit - output is readable

Y	Dump memory - prints all & only nonzero values in memory
Y	Dump memory - prints using reasonable %format
Y	Dump memory - output is readable

Y	Command loop - correctly prompts for/reads in first command
Y	Command loop - correctly prompts for/reads in non-first commands
__	XC	Command loop - handles EOF of command loop

Y	Command loop - correctly recognizes command letter h ? d j m q r
Y	Command loop - correctly recognizes numeric command
Y	Command loop - correctly recognizes carriage return
Y	XC	Command loop - complains about bad command character
Y	Command loop - calls correct routine to process command

Y	Command h - prints nice message
Y	Command d - dumps control unit and memory
Y	Command d - calls routines dump CU or memory (doesn't duplicate code)
Y	Command j - recognizes target of jump
Y	Command j - sets pc correctly
Y	XC	Command j - complains about bad location
Y	Command m - recognizes memory location, new value
Y	Command m - sets correct location to correct value
Y	XC	Command m - complains about bad location or value
Y	Command q - halts command loop
Y	Command <cr> - runs instruction cycle exactly once
Y	Command <nbr> - reads number correctly
Y	Command <nbr> - handles insanely large number
Y	Command <nbr> - runs instruction cycle correct number of times assuming no halt
Y	Command <nbr> - stops running instruction cycles on CPU halt
Y	XC	Command <nbr> - complains if number of cycles <= 0

Y	Instr cycle - sets ir <- memory[pc]
Y	Instr cycle - increments pc
Y	Instr cycle - echoes ir in hex
Y	Instr cycle - correctly identifies opcode, calls code for opcode

For instruction execution,
	"Getting" a field means correctly retrieving it from the ir
	"Naming" a field means printing it (e.g. R6 for register 6)
	"Displaying" a number means printing its value (e.g., pc+offset)
	"V-displaying" a register or memory location means printing its value

Y	Instr ADD - gets/names destination register
Y	Instr ADD - gets/names/v-displays source register 1
Y	Instr ADD - discriminates ADD immediate vs ADD register
Y	Instr ADD - gets/names/v-displays source register 2
Y	Instr ADD - gets/sign-extends/displays immediate value
Y	Instr ADD - calculates/assigns/displays sum
Y	Instr ADD - resets cc

Y	Instr AND - gets/names destination register
Y	Instr AND - gets/names/v-displays source register 1
Y	Instr AND - discriminates AND immediate vs AND register
Y	Instr AND - gets/names/v-displays source register 2
Y	Instr AND - gets/sign-extends/displays immediate value
Y	Instr AND - calculates/assigns/displays sum
Y	Instr AND - resets cc

Y	Instr BR - gets/sign-extends/displays offset
Y	Instr BR - displays kind of branch (BRN, etc.)
Y	Instr BR - indicates current cc, jump decision
Y	Instr BR - on jump, displays new pc

Y	Instr err - complains about reserved opcode, halts CPU

Y	Instr JMP - gets/v-displays base register
C	Instr JMP - sets pc <- reg[base]

Y	Instr JSR/JSRR - discriminates between JSR and JSRR
Y	Instr JSR - gets/sign-extends/displays offset
Y	Instr JSR - calculates/displays pc + offset
Y	Instr JSR - sets pc <- pc + offset
Y	Instr JSRR - gets/names/v-displays base register
Y	Instr JSRR - sets pc <- reg[base]
Y	Instr JSRR - handles case where base register is R7
Y	Instr JSR/JSRR - saves return address in R7

Y	Instr LD - gets/names destination register
Y	Instr LD - gets/sign-extends/displays offset
Y	Instr LD - calculates/displays pc + offset
Y	Instr LD - gets/v-displays memory[pc + offset]
Y	Instr LD - assigns destination register and resets cc

Y	Instr LDI - gets/names destination register
Y	Instr LDI - gets/sign-extends/displays offset
Y	Instr LDI - calculates/displays pc + offset
Y	Instr LDI - gets/v-displays memory[pc + offset]
Y	Instr LDI - gets/v-displays memory[memory[pc + offset]]
Y	Instr LDI - assigns destination register and resets cc

Y	Instr LDR - gets/names destination register
Y	Instr LDR - gets/sign-extends/v-displays base register
Y	Instr LDR - gets/sign-extends/displays offset
Y	Instr LDR - calculates/displays base + offset
Y	Instr LDR - gets/v-displays memory[base + offset]
Y	Instr LDR - assigns destination register and resets cc

Y	Instr LEA - gets/names destination register
Y	Instr LEA - gets/sign-extends/displays offset
Y	Instr LEA - calculates/displays pc + offset
Y	Instr LEA - assigns destination register and resets cc

Y	Instr NOT - gets/names destination register
Y	Instr NOT - gets/sign-extends/v-displays source register
Y	Instr NOT - calculates/displays bitwise NOT of source value
Y	Instr NOT - assigns destination register and resets cc

Y	Instr RTI - complains about unsupported command, halts CPU

Y	Instr ST - gets/names/v-displays source register
Y	Instr ST - gets/sign-extends/displays offset
Y	Instr ST - calculates/displays pc + offset
Y	Instr ST - assigns memory[pc + offset]

Y	Instr STI - gets/names/v-displays source register
Y	Instr STI - gets/sign-extends/displays offset
Y	Instr STI - calculates/displays pc + offset
Y	Instr STI - gets/v-displays memory[pc + offset]
Y	Instr STI - assigns memory[memory[pc + offset]]

Y	Instr STR - gets/names/v-displays source register
Y	Instr STR - gets/names/v-displays base register
Y	Instr STR - gets/sign-extends/displays offset
Y	Instr STR - calculates/displays base + offset
Y	Instr STR - assigns memory[base + offset]

Y	Instr TRAP - gets/displays/calls code for trap vector
Y	Instr TRAP - complains about bad trap vector and halts
Y	Instr TRAP - saves R7 <- pc, sets cc using R7 (except for HALT)
Y	Instr TRAP GETC (x20) - prompts user
Y	Instr TRAP GETC (x20) - reads a character (even if <cr>)
Y	Instr TRAP GETC (x20) - displays character read, assigns R0
Y	Instr TRAP IN (x23) - prompts user like LC-3 simulator
Y	Instr TRAP IN (x23) - reads a character (even if <cr>)
Y	Instr TRAP IN (x23) - displays character read, assigns it to R0
Y	Instr TRAP OUT (x21) - v-displays R0 (as integer & ASCII char)
Y	Instr TRAP PUTS (x22) - processes correct memory locations
Y	Instr TRAP PUTS (x22) - prints ASCII for each memory location
Y	Instr TRAP HALT (x25) - sets running flag <- false
Y	Instr TRAP HALT (x25) - sets cc to positive

For the categories below, mark y (yes), n (no), or p (partly) depending
on if/how much your program has these features

Y	Style - initial comment with name
Y	Style - CPU structure declaration is commented
Y	Style - block comment identifies function prototypes
Y	Style - block comments identifies major groups of routines
Y	Style - no global variables

Y	Style - block comments on function prototypes
Y	Style - repeatedly executed code is made into its own routine
Y	Style - routines appear in some reasonable order
Y	Style - names & comments on routines identify their actions
Y	Style - no huge routines

Y	Style - variables declared in good locations
Y	Style - names of/comments on variables identify their properties

Y	Style - main program - command loop written compactly
Y	Style - separate routines for each kind of command (possible exception: q)
Y	Style - separate routines for each opcode (possible exceptions: err, RTI)

If there are any things you want to mention about your project, please include them below.
Thank you for all your work on the project and during the semester.

I made a last minute change where I moved all of my code for the different opcodes into seperate functions.
They should all work with the appropriate ocode, but if an opcode is messed up, that is why.

also the way I detect which opcode it is, is probably not optimal, but escentially it converts the IR to
a string, then it can take out specific parts of that string to inspect certain parts of the IR.

Thanks for teaching me
Have a great break
Ben Shaughnessy